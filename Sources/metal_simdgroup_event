// -*- Metal -*-
//===-- metal_simdgroup_event ---------------------------------------------===//
// Copyright (c) 2023 Philip Turner. See MIT LICENSE
//===----------------------------------------------------------------------===//

#ifndef __METAL_SIMDGROUP_EVENT
#define __METAL_SIMDGROUP_EVENT

// Contains C++ symbols accessible to a developer through automatic code
// completion in Xcode 14.2. Formatted with the same style as the Metal Standard
// Library for consistency with other Metal code.

#if defined(__HAVE_SIMDGROUP_FUTURE__)
#include <metal_simdgroup_future>
#endif

#pragma METAL internals : enable
namespace metal
{
#if !defined(__HAVE_SIMDGROUP_FUTURE__)
  enum class simdgroup_async_copy_clamp_mode {
    clamp_to_zero = 0,
    clamp_to_edge = 1
  };
#endif
  
  struct simdgroup_event {
    METAL_FUNC simdgroup_event() thread {}
    
    template <typename T>
    METAL_FUNC void async_copy(threadgroup T *dst, const device T *src, ulong n_elements) thread {
#if defined(__HAVE_SIMDGROUP_FUTURE__)
      event = __metal_simdgroup_async_copy_1d(sizeof(T), alignof(T), reinterpret_cast<threadgroup void *>(dst), reinterpret_cast<const device void *>(src), n_elements);
#endif
    }
    
    template <typename T>
    METAL_FUNC void async_copy(device T *dst, const threadgroup T *src, ulong n_elements) thread {
#if defined(__HAVE_SIMDGROUP_FUTURE__)
      event = __metal_simdgroup_async_copy_1d(sizeof(T), alignof(T), reinterpret_cast<device void *>(dst), reinterpret_cast<const threadgroup void *>(src), n_elements);
#endif
    }
    
    template <typename T>
    METAL_FUNC void async_copy(threadgroup T *dst, ulong dst_elements_per_row, ulong2 dst_tile_dimensions, const device T *src, ulong src_elements_per_row, ulong2 src_tile_dimensions, long2 offset_in_src_tile, simdgroup_async_copy_clamp_mode clamp_mode, bool transpose_matrix = false) thread {
#if defined(__HAVE_SIMDGROUP_FUTURE__)
      if (transpose_matrix) {
        event = __metal_simdgroup_async_copy_2d(sizeof(T), alignof(T), reinterpret_cast<threadgroup void *>(dst), dst_elements_per_row, 1, dst_tile_dimensions.yx, reinterpret_cast<const device void *>(src), src_elements_per_row, 1, src_tile_dimensions.yx, offset_in_src_tile, static_cast<int>(clamp_mode));
      } else {
        event = __metal_simdgroup_async_copy_2d(sizeof(T), alignof(T), reinterpret_cast<threadgroup void *>(dst), dst_elements_per_row, 1, dst_tile_dimensions, reinterpret_cast<const device void *>(src), src_elements_per_row, 1, src_tile_dimensions, offset_in_src_tile, static_cast<int>(clamp_mode));
      }
#endif
    }
    
    template <typename T>
    METAL_FUNC void async_copy(device T *dst, ulong dst_elements_per_row,  ulong2 dst_tile_dimensions, long2 offset_in_dst_tile, const threadgroup T *src, ulong src_elements_per_row, ulong2 src_tile_dimensions, bool transpose_matrix = false) thread {
#if defined(__HAVE_SIMDGROUP_FUTURE__)
      if (transpose_matrix) {
        event = __metal_simdgroup_async_copy_2d(sizeof(T), alignof(T), reinterpret_cast<device void *>(dst), dst_elements_per_row, 1, dst_tile_dimensions.yx, reinterpret_cast<const threadgroup void *>(src), src_elements_per_row, src_element_stride, src_tile_dimensions.yx, offset_in_dst_tile, 0);
      } else {
        event = __metal_simdgroup_async_copy_2d(sizeof(T), alignof(T), reinterpret_cast<device void *>(dst), dst_elements_per_row, 1, dst_tile_dimensions, reinterpret_cast<const threadgroup void *>(src), src_elements_per_row, src_element_stride, src_tile_dimensions, offset_in_dst_tile, 0);
      }
#endif
    }
    
    METAL_FUNC static void wait(int count, thread simdgroup_event *events) {
#if defined(__HAVE_SIMDGROUP_FUTURE__)
      __metal_simdgroup_wait_events(count, reinterpret_cast<thread __metal_simdgroup_event_t*>(events));
#endif
    }
    
  private:
#if defined(__HAVE_SIMDGROUP_FUTURE__)
    __metal_simdgroup_event_t event;
#endif
  };
} // namespace metal
#pragma METAL internals : disable

#endif // __METAL_SIMDGROUP_EVENT
